<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Connectivity Monitor</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a2e;
            color: #eee;
            padding: 20px;
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #00d9ff;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: #16213e;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid #0f3460;
        }

        .stat-card h3 {
            font-size: 14px;
            color: #a0a0a0;
            margin-bottom: 8px;
        }

        .stat-card .value {
            font-size: 32px;
            font-weight: bold;
            color: #00d9ff;
        }

        .controls {
            background: #16213e;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 2px solid #0f3460;
        }

        .controls h2 {
            margin-bottom: 15px;
            color: #00d9ff;
            font-size: 18px;
        }

        .control-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        input, button {
            padding: 10px 15px;
            border-radius: 5px;
            border: 1px solid #0f3460;
            background: #1a1a2e;
            color: #eee;
            font-size: 14px;
        }

        button {
            cursor: pointer;
            background: #0f3460;
            transition: all 0.3s;
        }

        button:hover {
            background: #00d9ff;
            color: #1a1a2e;
        }

        select {
            padding: 10px 15px;
            border-radius: 5px;
            border: 1px solid #0f3460;
            background: #1a1a2e;
            color: #eee;
            font-size: 14px;
        }

        #network {
            background: #16213e;
            border-radius: 8px;
            border: 2px solid #0f3460;
            min-height: 1400px;
            width: 100%;
            display: block;
        }

        .node {
            cursor: pointer;
        }

        .node circle {
            stroke: #fff;
            stroke-width: 2px;
        }

        .node text {
            font-size: 12px;
            fill: #fff;
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none;
            font-weight: 500;
            text-shadow: 0 0 3px rgba(0,0,0,0.8);
        }

        .link {
            stroke: #ffffff;
            stroke-width: 2px;
            opacity: 0.4;
            stroke-dasharray: 5, 5;
            animation: dash 20s linear infinite;
        }

        @keyframes dash {
            to {
                stroke-dashoffset: -100;
            }
        }

        .status-online { fill: #4ade80; }
        .status-degraded { fill: #fbbf24; }
        .status-offline { fill: #ef4444; }

        .legend {
            position: absolute;
            top: 100px;
            right: 40px;
            background: #16213e;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #0f3460;
        }

        .legend h3 {
            margin-bottom: 10px;
            color: #00d9ff;
            font-size: 14px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 5px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Dynamic Network Connectivity Monitor</h1>

        <div class="stats" id="stats"></div>

        <div class="controls">
            <h2>Network Operations</h2>
            <div class="control-group">
                <input type="number" id="bulkCount" placeholder="Number of nodes" value="10" min="1" max="10000" style="width: 150px;">
                <button onclick="bulkAddServers()">Bulk Add Nodes</button>
                <span style="color: #a0a0a0; margin-left: 10px; font-size: 12px;">Names: Disney/Norse mythology</span>
            </div>
            <div class="control-group">
                <input type="text" id="serverName" placeholder="Server name (e.g., web-3)">
                <select id="serverStatus">
                    <option value="online">Online</option>
                    <option value="degraded">Degraded</option>
                    <option value="offline">Offline</option>
                </select>
                <button onclick="addServer()">Add Single Server</button>
            </div>
            <div class="control-group">
                <select id="fromServer"></select>
                <select id="toServer"></select>
                <button onclick="linkServers()">Connect Servers</button>
            </div>
            <div class="control-group">
                <select id="disconnectServer"></select>
                <button onclick="disconnectServer()">Disconnect Server</button>
            </div>
            <div class="control-group">
                <button onclick="refreshNetwork()">Refresh Network</button>
            </div>
            <div class="control-group">
                <button id="chaosToggle" onclick="toggleChaos()">Start Chaos Monkey</button>
                <label style="color: #a0a0a0; margin-left: 10px;">
                    Chaos Mode:
                    <select id="chaosMode">
                        <option value="mixed">Mixed (Connect & Disconnect)</option>
                        <option value="disconnect">Disconnect Only</option>
                        <option value="connect">Connect Only</option>
                    </select>
                </label>
                <label style="color: #a0a0a0; margin-left: 10px;">
                    Interval:
                    <select id="chaosInterval">
                        <option value="1000">Fast (1s)</option>
                        <option value="2000" selected>Normal (2s)</option>
                        <option value="5000">Slow (5s)</option>
                    </select>
                </label>
            </div>
        </div>

        <svg id="network"></svg>

        <div class="legend">
            <h3>Server Status</h3>
            <div class="legend-item">
                <div class="legend-color status-online"></div>
                <span>Online</span>
            </div>
            <div class="legend-item">
                <div class="legend-color status-degraded"></div>
                <span>Degraded</span>
            </div>
            <div class="legend-item">
                <div class="legend-color status-offline"></div>
                <span>Offline</span>
            </div>
        </div>
    </div>

    <script>
        const width = window.innerWidth - 80;
        const height = 1400;

        const svg = d3.select("#network")
            .attr("width", width)
            .attr("height", height)
            .attr("viewBox", `0 0 ${width} ${height}`);

        let simulation;
        let currentData = { nodes: [], links: [] };
        let link, node;

        async function fetchStats() {
            const response = await fetch('/api/stats');
            const stats = await response.json();

            document.getElementById('stats').innerHTML = `
                <div class="stat-card">
                    <h3>Total Servers</h3>
                    <div class="value">${stats.servers}</div>
                </div>
                <div class="stat-card">
                    <h3>Active Links</h3>
                    <div class="value">${stats.links}</div>
                </div>
                <div class="stat-card">
                    <h3>Network Partitions</h3>
                    <div class="value">${stats.partitions}</div>
                </div>
                <div class="stat-card">
                    <h3>Online</h3>
                    <div class="value" style="color: #4ade80">${stats.online}</div>
                </div>
                <div class="stat-card">
                    <h3>Degraded</h3>
                    <div class="value" style="color: #fbbf24">${stats.degraded}</div>
                </div>
                <div class="stat-card">
                    <h3>Offline</h3>
                    <div class="value" style="color: #ef4444">${stats.offline}</div>
                </div>
            `;
        }

        async function fetchNetwork() {
            const response = await fetch('/api/network');
            const data = await response.json();

            updateServerSelects(data.nodes);

            // Always do full render to avoid offset issues
            renderNetwork(data);
            currentData = data;

            fetchStats();
        }

        function updateServerSelects(nodes) {
            const fromSelect = document.getElementById('fromServer');
            const toSelect = document.getElementById('toServer');
            const disconnectSelect = document.getElementById('disconnectServer');

            [fromSelect, toSelect, disconnectSelect].forEach(select => {
                select.innerHTML = nodes.map(n =>
                    `<option value="${n.id}">${n.name} (${n.id})</option>`
                ).join('');
            });
        }

        function renderNetwork(data) {
            svg.selectAll("*").remove();

            if (simulation) simulation.stop();

            // Adjust force parameters based on number of nodes
            const nodeCount = data.nodes.length;
            const linkDistance = nodeCount > 500 ? 20 : (nodeCount > 50 ? 50 : 100);
            const linkStrength = nodeCount > 500 ? 0.8 : 0.7;
            const chargeStrength = nodeCount > 500 ? -30 : (nodeCount > 50 ? -80 : -200);
            const collisionRadius = nodeCount > 500 ? 8 : (nodeCount > 50 ? 20 : 40);

            simulation = d3.forceSimulation(data.nodes)
                .force("link", d3.forceLink(data.links)
                    .id(d => d.id)
                    .distance(d => linkDistance / (d.weight || 1))  // Shorter distance for higher weight
                    .strength(d => linkStrength * (d.weight || 1) / 5))  // Stronger pull for higher weight
                .force("charge", d3.forceManyBody().strength(chargeStrength))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("collision", d3.forceCollide().radius(collisionRadius))
                .force("x", d3.forceX(width / 2).strength(0.05))
                .force("y", d3.forceY(height / 2).strength(0.05))
                .velocityDecay(0.4)
                .alphaDecay(0.02)
                .alphaMin(0.001);

            const linkGroup = svg.append("g");
            const nodeGroup = svg.append("g");

            link = linkGroup.selectAll("line")
                .data(data.links)
                .join("line")
                .attr("class", "link")
                .attr("stroke-width", d => Math.max(1, (d.weight || 1) / 2));  // Thicker lines for higher weight

            node = nodeGroup.selectAll("g")
                .data(data.nodes, d => d.id)
                .join("g")
                .attr("class", "node")
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            const nodeRadius = nodeCount > 500 ? 6 : (nodeCount > 50 ? 18 : 25);
            const fontSize = nodeCount > 500 ? 0 : (nodeCount > 50 ? 11 : 12);

            node.append("circle")
                .attr("r", nodeRadius)
                .attr("class", d => `status-${d.status}`);

            if (fontSize > 0) {
                node.append("text")
                    .text(d => d.name)
                    .attr("dy", ".35em")
                    .style("font-size", `${fontSize}px`);
            }

            simulation.on("tick", tick);
        }

        function updateNetwork(data) {
            // Preserve positions by copying from current simulation nodes to new data
            const oldPositions = new Map();
            if (simulation && simulation.nodes()) {
                simulation.nodes().forEach(n => {
                    if (n.x !== undefined && n.y !== undefined) {
                        oldPositions.set(n.id, {
                            x: n.x,
                            y: n.y,
                            vx: n.vx || 0,
                            vy: n.vy || 0,
                            fx: n.fx,
                            fy: n.fy
                        });
                    }
                });
            }

            // Apply preserved positions to new data
            data.nodes.forEach(n => {
                const oldPos = oldPositions.get(n.id);
                if (oldPos) {
                    n.x = oldPos.x;
                    n.y = oldPos.y;
                    n.vx = oldPos.vx;
                    n.vy = oldPos.vy;
                    if (oldPos.fx !== undefined) n.fx = oldPos.fx;
                    if (oldPos.fy !== undefined) n.fy = oldPos.fy;
                }
            });

            const nodeCount = data.nodes.length;
            const nodeRadius = nodeCount > 500 ? 6 : (nodeCount > 50 ? 18 : 25);
            const fontSize = nodeCount > 500 ? 0 : (nodeCount > 50 ? 11 : 12);

            // Update simulation nodes FIRST
            simulation.nodes(data.nodes);

            // Update link force BEFORE updating visual links
            // This allows D3 to bind source/target to the correct node objects
            simulation.force("link").links(data.links);

            // Force one tick to initialize link bindings without animation
            simulation.tick();

            // Then update visual elements
            node = node.data(data.nodes, d => d.id)
                .join(
                    enter => {
                        const g = enter.append("g")
                            .attr("class", "node")
                            .call(d3.drag()
                                .on("start", dragstarted)
                                .on("drag", dragged)
                                .on("end", dragended));

                        g.append("circle")
                            .attr("r", nodeRadius)
                            .attr("class", d => `status-${d.status}`);

                        if (fontSize > 0) {
                            g.append("text")
                                .text(d => d.name)
                                .attr("dy", ".35em")
                                .style("font-size", `${fontSize}px`);
                        }
                        return g;
                    },
                    update => update.select("circle").attr("class", d => `status-${d.status}`),
                    exit => exit.remove()
                );

            // Update visual links AFTER simulation has bound them
            link = link.data(data.links, d => `${d.source.id || d.source}-${d.target.id || d.target}`)
                .join("line")
                .attr("class", "link");

            // Now restart with animation
            simulation.alpha(0.8).restart();
        }

        function tick() {
            if (!simulation || !simulation.nodes()) return;

            const simNodes = simulation.nodes();

            // Constrain nodes to viewport with padding
            simNodes.forEach(d => {
                d.x = Math.max(30, Math.min(width - 30, d.x));
                d.y = Math.max(30, Math.min(height - 30, d.y));
            });

            if (link) {
                link.attr("x1", d => {
                    const source = typeof d.source === 'object' ? d.source : simNodes.find(n => n.id === d.source);
                    return source ? source.x : 0;
                })
                .attr("y1", d => {
                    const source = typeof d.source === 'object' ? d.source : simNodes.find(n => n.id === d.source);
                    return source ? source.y : 0;
                })
                .attr("x2", d => {
                    const target = typeof d.target === 'object' ? d.target : simNodes.find(n => n.id === d.target);
                    return target ? target.x : 0;
                })
                .attr("y2", d => {
                    const target = typeof d.target === 'object' ? d.target : simNodes.find(n => n.id === d.target);
                    return target ? target.y : 0;
                });
            }

            if (node) {
                node.attr("transform", d => `translate(${d.x},${d.y})`);
            }
        }

        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        async function bulkAddServers() {
            const count = parseInt(document.getElementById('bulkCount').value);

            if (!count || count < 1) {
                alert('Please enter a valid number of nodes');
                return;
            }

            if (count > 10000) {
                alert('Maximum 10000 nodes at once');
                return;
            }

            const response = await fetch('/api/bulk-add', {
                method: 'POST',
                body: JSON.stringify({ count })
            });

            const result = await response.json();
            console.log(`Bulk added ${result.created} nodes, total: ${result.total}`);
            fetchNetwork();
        }

        async function addServer() {
            const name = document.getElementById('serverName').value;
            const status = document.getElementById('serverStatus').value;

            if (!name) {
                alert('Please enter a server name');
                return;
            }

            await fetch('/api/server', {
                method: 'POST',
                body: JSON.stringify({ name, status })
            });

            document.getElementById('serverName').value = '';
            fetchNetwork();
        }

        async function linkServers() {
            const from = parseInt(document.getElementById('fromServer').value);
            const to = parseInt(document.getElementById('toServer').value);

            await fetch('/api/link', {
                method: 'POST',
                body: JSON.stringify({ from, to })
            });

            fetchNetwork();
        }

        async function disconnectServer() {
            const server = parseInt(document.getElementById('disconnectServer').value);

            await fetch('/api/disconnect', {
                method: 'POST',
                body: JSON.stringify({ server })
            });

            fetchNetwork();
        }

        function refreshNetwork() {
            fetchNetwork();
        }

        // Chaos Monkey implementation
        let chaosInterval = null;
        let chaosRunning = false;

        function toggleChaos() {
            const button = document.getElementById('chaosToggle');

            if (chaosRunning) {
                clearInterval(chaosInterval);
                chaosInterval = null;
                chaosRunning = false;
                button.textContent = 'Start Chaos Monkey';
                button.style.background = '#0f3460';
            } else {
                const interval = parseInt(document.getElementById('chaosInterval').value);
                chaosInterval = setInterval(runChaos, interval);
                chaosRunning = true;
                button.textContent = 'Stop Chaos Monkey';
                button.style.background = '#ef4444';
            }
        }

        async function runChaos() {
            const mode = document.getElementById('chaosMode').value;
            const response = await fetch('/api/network');
            const data = await response.json();

            if (data.nodes.length === 0) return;

            let action;
            if (mode === 'mixed') {
                action = Math.random() > 0.5 ? 'connect' : 'disconnect';
            } else if (mode === 'connect') {
                action = 'connect';
            } else {
                action = 'disconnect';
            }

            if (action === 'disconnect' && data.nodes.length > 0) {
                // Randomly disconnect a server
                const randomServer = data.nodes[Math.floor(Math.random() * data.nodes.length)];
                await fetch('/api/disconnect', {
                    method: 'POST',
                    body: JSON.stringify({ server: randomServer.id })
                });
                console.log(`Chaos: Disconnected server ${randomServer.name} (${randomServer.id})`);
            } else if (action === 'connect' && data.nodes.length >= 2) {
                // Randomly connect two servers
                const a = data.nodes[Math.floor(Math.random() * data.nodes.length)];
                let b = data.nodes[Math.floor(Math.random() * data.nodes.length)];

                // Make sure we don't connect a server to itself
                let attempts = 0;
                while (b.id === a.id && attempts < 10) {
                    b = data.nodes[Math.floor(Math.random() * data.nodes.length)];
                    attempts++;
                }

                if (b.id !== a.id) {
                    await fetch('/api/link', {
                        method: 'POST',
                        body: JSON.stringify({ from: a.id, to: b.id })
                    });
                    console.log(`Chaos: Connected ${a.name} (${a.id}) to ${b.name} (${b.id})`);
                }
            }

            // Refresh the visualization
            fetchNetwork();
        }

        // Initial load
        fetchNetwork();

        // Optional: Auto-refresh every 30 seconds (disabled by default to keep layout stable)
        // setInterval(fetchNetwork, 30000);
    </script>
</body>
</html>
