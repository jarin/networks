<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="netlang.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
        }

        .main-container {
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            grid-template-rows: 60px 1fr 250px;
            height: 100vh;
            gap: 0;
        }

        .header {
            grid-column: 1 / -1;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
            display: flex;
            align-items: center;
            padding: 0 20px;
            justify-content: space-between;
        }

        .header h1 {
            font-size: 20px;
            color: #00ff88;
            font-weight: 500;
        }

        .stats-inline {
            display: flex;
            gap: 30px;
            font-size: 13px;
        }

        .stat-inline {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-inline .label {
            color: #888;
        }

        .stat-inline .value {
            color: #00ff88;
            font-weight: 600;
        }

        .left-panel, .right-panel {
            background: #151515;
            border-right: 1px solid #333;
            padding: 15px;
            overflow-y: auto;
        }

        .right-panel {
            border-right: none;
            border-left: 1px solid #333;
        }

        .canvas-container {
            position: relative;
            background: #0a0a0a;
            overflow: hidden;
        }

        #network {
            width: 100%;
            height: 100%;
        }

        .panel-section {
            margin-bottom: 20px;
        }

        .panel-section h3 {
            font-size: 12px;
            color: #00ff88;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .control-row {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 10px;
        }

        input, select, button {
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #333;
            background: #0a0a0a;
            color: #e0e0e0;
            font-size: 12px;
            width: 100%;
        }

        button {
            cursor: pointer;
            background: #1a1a1a;
            transition: all 0.2s;
            font-weight: 500;
        }

        button:hover {
            background: #00ff88;
            color: #0a0a0a;
            border-color: #00ff88;
        }

        button.danger {
            background: #ff4a4a;
            border-color: #ff4a4a;
            color: #0a0a0a;
        }

        button.danger:hover {
            background: #ff2020;
            border-color: #ff2020;
        }

        .link {
            stroke: #666;
            stroke-opacity: 0.6;
            fill: none;
            stroke-width: 2px;
        }

        .node circle {
            stroke: #0a0a0a;
            stroke-width: 2px;
            fill: #00ff88;
            cursor: pointer;
        }

        .node.selected circle {
            fill: #4a9eff;
            stroke: #4a9eff;
            stroke-width: 3px;
        }

        .node.offline circle {
            fill: #ff4a4a;
        }

        .node text {
            fill: #0a0a0a;
            text-anchor: middle;
            pointer-events: none;
            user-select: none;
            font-weight: 600;
            font-size: 12px;
        }

        .node.selected text {
            fill: #ffffff;
        }

        .weight-label {
            fill: #888;
            font-size: 10px;
            text-anchor: middle;
            pointer-events: none;
        }

        .legend {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: rgba(26, 26, 26, 0.9);
            padding: 12px;
            border-radius: 4px;
            border: 1px solid #333;
            font-size: 11px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }

        .status-bar {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: #1a1a1a;
            padding: 10px 20px;
            border-radius: 4px;
            border: 1px solid #333;
            font-size: 13px;
            z-index: 1000;
            display: none;
        }

        .node-list {
            max-height: 200px;
            overflow-y: auto;
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 8px;
        }

        .node-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            margin-bottom: 4px;
            background: #1a1a1a;
            border-radius: 3px;
            font-size: 11px;
        }

        .node-item:hover {
            background: #2a2a2a;
        }

        .node-item .name {
            color: #00ff88;
            font-weight: 600;
        }

        .node-item .id {
            color: #888;
            font-size: 10px;
        }

        .node-item button {
            padding: 2px 6px;
            font-size: 10px;
            width: auto;
        }

        .algorithm-panel {
            grid-column: 1 / -1;
            background: #151515;
            border-top: 1px solid #333;
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 10px;
            padding: 10px;
        }

        .code-section, .console-section {
            display: flex;
            flex-direction: column;
        }

        .code-section h3, .console-section h3 {
            font-size: 12px;
            color: #00ff88;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #codeEditor {
            flex: 1;
            background: #0a0a0a;
            color: #e0e0e0;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: none;
        }

        #console {
            flex: 1;
            background: #0a0a0a;
            color: #888;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            overflow-y: auto;
        }

        .algorithm-controls {
            display: flex;
            gap: 5px;
            margin-top: 5px;
        }

        .algorithm-controls select {
            flex: 1;
        }

        .algorithm-controls button {
            width: auto;
            padding: 6px 12px;
        }

        #console .log-entry {
            margin-bottom: 2px;
            color: #e0e0e0;
        }

        #console .log-error {
            color: #ff4a4a;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="header">
            <h1>Dynamic Network Visualization</h1>
            <div class="stats-inline">
                <div class="stat-inline">
                    <span class="label">Nodes:</span>
                    <span class="value" id="nodeCount">0</span>
                </div>
                <div class="stat-inline">
                    <span class="label">Edges:</span>
                    <span class="value" id="edgeCount">0</span>
                </div>
                <div class="stat-inline">
                    <span class="label">Selected:</span>
                    <span class="value" id="selectedNode">None</span>
                </div>
            </div>
        </div>

        <div class="left-panel">
            <div class="panel-section">
                <h3>Create Network</h3>
                <div class="control-row">
                    <input type="number" id="networkSize" placeholder="Number of nodes" value="8" min="2" max="200">
                    <label style="font-size: 11px; color: #888; margin-top: 5px;">
                        Connectivity:
                    </label>
                    <input type="range" id="connectivity" min="1" max="4" value="2" step="1">
                    <div style="display: flex; justify-content: space-between; font-size: 10px; color: #666; margin-top: -5px;">
                        <span>Sparse</span>
                        <span>Dense</span>
                    </div>
                    <button onclick="createNetwork()">Create Network</button>
                </div>
            </div>

            <div class="panel-section">
                <h3>Add Nodes</h3>
                <div class="control-row">
                    <input type="text" id="nodeName" placeholder="Node name" value="">
                    <button onclick="addSingleNode()">Add Single Node</button>
                </div>
                <div class="control-row">
                    <input type="number" id="bulkCount" placeholder="Number of nodes" value="5" min="1" max="100">
                    <button onclick="bulkAddNodes()">Add Multiple Nodes</button>
                </div>
            </div>

            <div class="panel-section">
                <h3>Add Edge</h3>
                <div class="control-row">
                    <select id="sourceNode">
                        <option value="">Select source node</option>
                    </select>
                    <select id="targetNode">
                        <option value="">Select target node</option>
                    </select>
                    <input type="number" id="edgeWeight" placeholder="Weight (optional)" min="1" max="100">
                    <button onclick="addEdge()">Create Edge</button>
                </div>
                <div class="control-row">
                    <label style="color: #888; font-size: 11px; margin-top: 5px;">
                        Or click two nodes in the canvas
                    </label>
                </div>
            </div>

            <div class="panel-section">
                <h3>Network Actions</h3>
                <div class="control-row">
                    <button onclick="removeSelected()">Remove Selected Node</button>
                    <button class="danger" onclick="clearNetwork()">Clear Network</button>
                </div>
            </div>
        </div>

        <div class="canvas-container">
            <svg id="network"></svg>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #00ff88;"></div>
                    <span>Online Node</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4a9eff;"></div>
                    <span>Selected Node</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff4a4a;"></div>
                    <span>Offline Node</span>
                </div>
            </div>
        </div>

        <div class="right-panel">
            <div class="panel-section">
                <h3>Network Nodes</h3>
                <div class="node-list" id="nodeList">
                    <div style="color: #888; font-size: 11px; text-align: center; padding: 20px;">
                        No nodes yet
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <h3>Instructions</h3>
                <div style="font-size: 11px; color: #888; line-height: 1.6;">
                    <p><strong style="color: #00ff88;">Building Networks:</strong></p>
                    <ul style="margin-left: 15px; margin-top: 5px;">
                        <li>Add individual nodes or create multiple at once</li>
                        <li>Click nodes to select them</li>
                        <li>Create edges by selecting source and target</li>
                        <li>Drag nodes to reposition them</li>
                    </ul>
                    <p style="margin-top: 10px;"><strong style="color: #00ff88;">Keyboard:</strong></p>
                    <ul style="margin-left: 15px; margin-top: 5px;">
                        <li>Delete key: Remove selected node</li>
                    </ul>
                </div>
            </div>

            <div class="panel-section">
                <h3>Selection Mode</h3>
                <div class="control-row">
                    <label style="color: #888; font-size: 11px;">
                        <input type="radio" name="mode" value="select" checked> Select nodes
                    </label>
                    <label style="color: #888; font-size: 11px;">
                        <input type="radio" name="mode" value="connect"> Connect nodes
                    </label>
                </div>
            </div>
        </div>

        <div class="algorithm-panel">
            <div class="code-section">
                <h3>Algorithm Code</h3>
                <textarea id="codeEditor" spellcheck="false"></textarea>
                <div class="algorithm-controls">
                    <select id="exampleSelect" onchange="loadExample()">
                        <option value="">Select Example...</option>
                        <option value="bfs">BFS - Breadth First Search</option>
                    </select>
                    <button onclick="runAlgorithm()" style="background: #00ff88; color: #0a0a0a;">Run</button>
                    <button onclick="stopAlgorithm()" style="background: #ff4a4a; color: #0a0a0a;">Stop</button>
                    <button onclick="clearHighlights()">Clear</button>
                </div>
            </div>
            <div class="console-section">
                <h3>Console Output</h3>
                <div id="console"></div>
            </div>
        </div>
    </div>

    <div id="statusBar" class="status-bar">
        <span id="statusMessage"></span>
    </div>

    <script>
        const container = document.querySelector('.canvas-container');
        const width = container.clientWidth;
        const height = container.clientHeight;

        const svg = d3.select("#network")
            .attr("width", width)
            .attr("height", height);

        // Add zoom/pan capability
        const g = svg.append("g");
        const zoom = d3.zoom()
            .scaleExtent([0.1, 10])
            .on("zoom", (event) => {
                g.attr("transform", event.transform);
            });
        svg.call(zoom);

        // Add arrowhead marker
        const defs = svg.append("defs");
        defs.append("marker")
            .attr("id", "arrowhead")
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 25)
            .attr("refY", 0)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5")
            .attr("fill", "#666");

        let simulation;
        let nodes = [];
        let links = [];
        let selectedNode = null;
        let firstSelectedForConnection = null;
        let lastNodeCount = 0;
        let lastLinkCount = 0;

        let linkGroup = g.append("g").attr("class", "links");
        let nodeGroup = g.append("g").attr("class", "nodes");

        function showStatus(message, isError = false) {
            const statusBar = document.getElementById('statusBar');
            const statusMessage = document.getElementById('statusMessage');
            statusMessage.textContent = message;
            statusMessage.style.color = isError ? '#ff4a4a' : '#00ff88';
            statusBar.style.display = 'block';
            setTimeout(() => {
                statusBar.style.display = 'none';
            }, 3000);
        }

        function getMode() {
            return document.querySelector('input[name="mode"]:checked').value;
        }

        async function createNetwork() {
            const count = parseInt(document.getElementById('networkSize').value);
            const connectivity = parseInt(document.getElementById('connectivity').value);

            if (!count || count < 2) {
                showStatus('Need at least 2 nodes', true);
                return;
            }

            try {
                // First clear the network
                await fetch('/api/clear', { method: 'POST' });

                // Add nodes
                const bulkResponse = await fetch('/api/bulk-add', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ count: count })
                });

                if (!bulkResponse.ok) {
                    showStatus('Failed to create nodes', true);
                    return;
                }

                // Wait a bit for nodes to be created
                await new Promise(resolve => setTimeout(resolve, 100));
                await fetchNetwork();

                // Create edges based on connectivity
                let minConnections, maxConnections;
                switch(connectivity) {
                    case 1: minConnections = 1; maxConnections = 2; break; // Sparse
                    case 2: minConnections = 2; maxConnections = 4; break; // Medium
                    case 3: minConnections = 3; maxConnections = 6; break; // Dense
                    case 4: minConnections = 4; maxConnections = 8; break; // Very Dense
                    default: minConnections = 2; maxConnections = 4;
                }

                const existingEdges = new Set();

                for (let i = 0; i < count; i++) {
                    const connections = minConnections + Math.floor(Math.random() * (maxConnections - minConnections + 1));

                    for (let j = 0; j < connections; j++) {
                        // Mix of sequential and random connections
                        const target = j < 2 ?
                            (i + j + 1) % count :
                            Math.floor(Math.random() * count);

                        if (i !== target) {
                            const edgeKey = `${i}-${target}`;
                            if (!existingEdges.has(edgeKey)) {
                                existingEdges.add(edgeKey);
                                const weight = 1 + Math.floor(Math.random() * 10);

                                await fetch('/api/link', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ from: i, to: target, weight: weight })
                                });
                            }
                        }
                    }
                }

                await fetchNetwork();
                showStatus(`Created network with ${count} nodes`);
            } catch (error) {
                showStatus('Failed to create network', true);
            }
        }

        async function addSingleNode() {
            const nameInput = document.getElementById('nodeName');
            const name = nameInput.value.trim() || `N${nodes.length}`;

            try {
                const response = await fetch('/api/server', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: name, status: 'online' })
                });

                if (response.ok) {
                    nameInput.value = '';
                    await fetchNetwork();
                    showStatus(`Added node: ${name}`);
                }
            } catch (error) {
                showStatus('Failed to add node', true);
            }
        }

        async function bulkAddNodes() {
            const count = parseInt(document.getElementById('bulkCount').value);
            if (!count || count < 1) {
                showStatus('Invalid number of nodes', true);
                return;
            }

            try {
                const response = await fetch('/api/bulk-add', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ count: count })
                });

                if (response.ok) {
                    await fetchNetwork();
                    showStatus(`Added ${count} nodes`);
                }
            } catch (error) {
                showStatus('Failed to add nodes', true);
            }
        }

        async function addEdge() {
            const sourceId = parseInt(document.getElementById('sourceNode').value);
            const targetId = parseInt(document.getElementById('targetNode').value);
            const weight = parseInt(document.getElementById('edgeWeight').value) || 1;

            if (isNaN(sourceId) || isNaN(targetId)) {
                showStatus('Please select both source and target nodes', true);
                return;
            }

            if (sourceId === targetId) {
                showStatus('Cannot create self-loop', true);
                return;
            }

            try {
                const response = await fetch('/api/link', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ from: sourceId, to: targetId, weight: weight })
                });

                if (response.ok) {
                    await fetchNetwork();
                    showStatus(`Created edge: ${sourceId} → ${targetId}`);
                }
            } catch (error) {
                showStatus('Failed to create edge', true);
            }
        }

        async function removeSelected() {
            if (selectedNode === null) {
                showStatus('No node selected', true);
                return;
            }

            try {
                const response = await fetch('/api/disconnect', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ server: selectedNode })
                });

                if (response.ok) {
                    selectedNode = null;
                    await fetchNetwork();
                    showStatus('Node removed');
                }
            } catch (error) {
                showStatus('Failed to remove node', true);
            }
        }

        async function clearNetwork() {
            if (!confirm('Clear entire network?')) return;

            try {
                const response = await fetch('/api/clear', {
                    method: 'POST'
                });

                if (response.ok) {
                    selectedNode = null;
                    await fetchNetwork();
                    showStatus('Network cleared');
                }
            } catch (error) {
                showStatus('Failed to clear network', true);
            }
        }

        async function fetchNetwork() {
            try {
                const response = await fetch('/api/network');
                const data = await response.json();

                nodes = data.nodes || [];
                links = data.links || [];

                updateSelects();
                updateVisualization();
                updateNodeList();
                updateStats();
            } catch (error) {
                console.error('Failed to fetch network:', error);
            }
        }

        function updateSelects() {
            const sourceSelect = document.getElementById('sourceNode');
            const targetSelect = document.getElementById('targetNode');

            [sourceSelect, targetSelect].forEach(select => {
                const currentValue = select.value;
                select.innerHTML = '<option value="">Select node</option>' +
                    nodes.map(n => `<option value="${n.id}">${n.name}</option>`).join('');
                select.value = currentValue;
            });
        }

        function updateNodeList() {
            const nodeList = document.getElementById('nodeList');
            if (nodes.length === 0) {
                nodeList.innerHTML = '<div style="color: #888; font-size: 11px; text-align: center; padding: 20px;">No nodes yet</div>';
                return;
            }

            nodeList.innerHTML = nodes.map(n => `
                <div class="node-item">
                    <div>
                        <span class="name">${n.name}</span>
                        <span class="id">#${n.id}</span>
                    </div>
                    <button onclick="selectNodeById(${n.id})">Select</button>
                </div>
            `).join('');
        }

        function updateStats() {
            document.getElementById('nodeCount').textContent = nodes.length;
            document.getElementById('edgeCount').textContent = links.length;
            document.getElementById('selectedNode').textContent =
                selectedNode !== null ? nodes.find(n => n.id === selectedNode)?.name || 'None' : 'None';
        }

        function selectNodeById(id) {
            selectedNode = id;
            updateVisualization();
            updateStats();
        }

        function updateVisualization() {
            if (!linkGroup || !nodeGroup) return;

            // Check if data actually changed
            const dataChanged = nodes.length !== lastNodeCount || links.length !== lastLinkCount;
            lastNodeCount = nodes.length;
            lastLinkCount = links.length;

            // Initialize simulation if needed
            if (!simulation) {
                simulation = d3.forceSimulation(nodes)
                    .force("link", d3.forceLink(links).id(d => d.id).distance(150))
                    .force("charge", d3.forceManyBody().strength(-500))
                    .force("center", d3.forceCenter(width / 2, height / 2))
                    .force("collision", d3.forceCollide().radius(40));

                simulation.on("tick", () => {
                    linkGroup.selectAll("line")
                        .attr("x1", d => d.source.x)
                        .attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x)
                        .attr("y2", d => d.target.y);

                    linkGroup.selectAll("text")
                        .attr("x", d => (d.source.x + d.target.x) / 2)
                        .attr("y", d => (d.source.y + d.target.y) / 2);

                    nodeGroup.selectAll("g")
                        .attr("transform", d => `translate(${d.x},${d.y})`);
                });
            }

            // Update simulation data
            simulation.nodes(nodes);
            simulation.force("link").links(links);

            // Only restart simulation if data changed
            if (dataChanged) {
                simulation.alpha(0.3).restart();
            }

            // Update links
            linkGroup.selectAll("line")
                .data(links, d => `${d.source.id || d.source}-${d.target.id || d.target}`)
                .join("line")
                .attr("class", "link")
                .attr("marker-end", "url(#arrowhead)");

            // Update link labels
            linkGroup.selectAll("text")
                .data(links, d => `${d.source.id || d.source}-${d.target.id || d.target}`)
                .join("text")
                .attr("class", "weight-label")
                .text(d => d.weight || 1);

            // Update nodes
            const nodeElements = nodeGroup.selectAll("g")
                .data(nodes, d => d.id)
                .join("g")
                .attr("class", d => {
                    let classes = "node";
                    if (d.id === selectedNode) classes += " selected";
                    if (d.status === "offline") classes += " offline";
                    return classes;
                })
                .call(d3.drag()
                    .on("start", dragStarted)
                    .on("drag", dragged)
                    .on("end", dragEnded))
                .on("click", nodeClicked);

            nodeElements.each(function(d) {
                const g = d3.select(this);
                g.selectAll("*").remove();
                g.append("circle").attr("r", 20);
                g.append("text")
                    .text(d.name)
                    .attr("dy", ".35em");
            });
        }

        function nodeClicked(event, d) {
            event.stopPropagation();

            const mode = getMode();
            if (mode === 'select') {
                selectedNode = d.id;
                firstSelectedForConnection = null;
                updateVisualization();
                updateStats();
            } else if (mode === 'connect') {
                if (firstSelectedForConnection === null) {
                    firstSelectedForConnection = d.id;
                    showStatus(`First node selected: ${d.name}. Click another node to connect.`);
                } else {
                    if (firstSelectedForConnection !== d.id) {
                        // Create connection
                        document.getElementById('sourceNode').value = firstSelectedForConnection;
                        document.getElementById('targetNode').value = d.id;
                        addEdge();
                    }
                    firstSelectedForConnection = null;
                }
            }
        }

        function dragStarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragEnded(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                e.preventDefault();
                removeSelected();
            }
        });

        // ====================================================================
        // ALGORITHM EXECUTION
        // ====================================================================

        let algorithmRunning = false;
        let currentInterpreter = null;

        const EXAMPLES = {
            bfs: `// BFS from source node 0
let source = 0
let visited = {}
let q = queue()

enqueue(q, source)
add(visited, source)
highlight_node(source, "current")
log("Starting BFS from node " + source)
sleep(500)

while not is_empty(q) {
    let current = dequeue(q)
    highlight_node(current, "visiting")
    log("Visiting node " + current)
    sleep(300)

    for neighbor in neighbors(current) {
        if not has(visited, neighbor) {
            add(visited, neighbor)
            enqueue(q, neighbor)
            highlight_edge(current, neighbor, "active")
            log("  Discovered node " + neighbor)
            sleep(200)
        }
    }

    highlight_node(current, "visited")
}

log("BFS complete! Visited " + size(visited) + " nodes")`
        };

        function loadExample() {
            const select = document.getElementById('exampleSelect');
            const example = EXAMPLES[select.value];
            if (example) {
                document.getElementById('codeEditor').value = example;
            }
        }

        function clearConsole() {
            document.getElementById('console').innerHTML = '';
        }

        function logToConsole(message, isError = false) {
            const console = document.getElementById('console');
            const entry = document.createElement('div');
            entry.className = isError ? 'log-error' : 'log-entry';
            entry.textContent = message;
            console.appendChild(entry);
            console.scrollTop = console.scrollHeight;
        }

        function clearVisualizationHighlights() {
            // Clear node highlighting
            nodeGroup.selectAll("g")
                .attr("class", d => {
                    let classes = "node";
                    if (d.id === selectedNode) classes += " selected";
                    if (d.status === "offline") classes += " offline";
                    return classes;
                });

            // Clear edge highlighting
            linkGroup.selectAll("line")
                .attr("class", "link")
                .attr("stroke", "#666")
                .attr("stroke-width", 2);

            // Clear labels
            nodeGroup.selectAll("text").each(function(d) {
                d3.select(this).text(d.name);
            });

            linkGroup.selectAll("text").remove();
        }

        // Helper to get node ID (handles D3 force simulation object refs)
        function getNodeId(node) {
            return node.id !== undefined ? node.id : node;
        }

        // Graph API for NetLang
        const graphAPI = {
            nodes: () => nodes.map(n => n.id),
            neighbors: (id) => {
                return links
                    .filter(l => getNodeId(l.source) === id)
                    .map(l => getNodeId(l.target));
            },
            edges: () => {
                return links.map(l => ({
                    from: getNodeId(l.source),
                    to: getNodeId(l.target),
                    weight: l.weight || 1
                }));
            },
            weight: (from, to) => {
                const link = links.find(l =>
                    getNodeId(l.source) === from &&
                    getNodeId(l.target) === to
                );
                return link ? (link.weight || 1) : null;
            },
            nodeCount: () => nodes.length,
            highlightNode: (id, color) => {
                const colorMap = {
                    'current': '#ff4a4a',
                    'visiting': '#ffaa00',
                    'visited': '#00ff88',
                    'path': '#4a9eff'
                };
                nodeGroup.selectAll("g").filter(d => d.id === id)
                    .select("circle")
                    .attr("fill", colorMap[color] || color);
            },
            highlightEdge: (from, to, color) => {
                const colorMap = {
                    'active': '#00ff88',
                    'path': '#4a9eff',
                    'relaxed': '#ffaa00'
                };
                linkGroup.selectAll("line")
                    .filter(d => getNodeId(d.source) === from &&
                                 getNodeId(d.target) === to)
                    .attr("stroke", colorMap[color] || color)
                    .attr("stroke-width", 3);
            },
            setNodeLabel: (id, text) => {
                nodeGroup.selectAll("g").filter(d => d.id === id)
                    .select("text")
                    .text(text);
            },
            setEdgeLabel: (from, to, text) => {
                // Find edge midpoint and add label
                const link = links.find(l =>
                    getNodeId(l.source) === from &&
                    getNodeId(l.target) === to
                );
                if (link) {
                    const sx = link.source.x !== undefined ? link.source.x : nodes[link.source].x;
                    const sy = link.source.y !== undefined ? link.source.y : nodes[link.source].y;
                    const tx = link.target.x !== undefined ? link.target.x : nodes[link.target].x;
                    const ty = link.target.y !== undefined ? link.target.y : nodes[link.target].y;

                    linkGroup.append("text")
                        .attr("class", "weight-label")
                        .attr("x", (sx + tx) / 2)
                        .attr("y", (sy + ty) / 2 - 5)
                        .text(text);
                }
            },
            log: (msg) => logToConsole(String(msg)),
            sleep: (ms) => new Promise(resolve => setTimeout(resolve, ms))
        };

        async function runAlgorithm() {
            if (algorithmRunning) {
                logToConsole('Algorithm already running', true);
                return;
            }

            const code = document.getElementById('codeEditor').value;
            if (!code.trim()) {
                logToConsole('No code to execute', true);
                return;
            }

            clearConsole();
            clearVisualizationHighlights();
            algorithmRunning = true;

            try {
                logToConsole('Compiling...');
                const lexer = new Lexer(code);
                const tokens = lexer.tokenize();
                const parser = new Parser(tokens);
                const ast = parser.parse();

                logToConsole('Executing...');
                currentInterpreter = new Interpreter(graphAPI);
                await currentInterpreter.execute(ast);

                logToConsole('--- Execution Complete ---');
            } catch (error) {
                logToConsole('Error: ' + error.message, true);
                console.error(error);
            } finally {
                algorithmRunning = false;
                currentInterpreter = null;
            }
        }

        function stopAlgorithm() {
            if (algorithmRunning) {
                algorithmRunning = false;
                currentInterpreter = null;
                logToConsole('--- Execution Stopped ---', true);
            }
        }

        function clearHighlights() {
            clearVisualizationHighlights();
            logToConsole('Cleared all highlights');
        }

        // Initial load
        fetchNetwork();
        loadExample(); // Load default BFS example
    </script>
</body>
</html>
